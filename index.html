<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>PDF Navigator</title>
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 10px;
      -webkit-text-size-adjust: 100%;
    }
    #pdf-container {
      position: relative;
      margin-top: 10px;
    }
    canvas {
      width: 100%;
      border: 1px solid #ddd;
    }
    .textLayer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .highlight {
      background-color: rgba(255, 255, 0, 0.5);
      border-radius: 2px;
    }
    .highlight.active {
      background-color: rgba(255, 165, 0, 0.7);
    }
    .search-controls {
      position: sticky;
      top: 0;
      background: white;
      padding: 8px 0;
      z-index: 100;
    }
    button {
      -webkit-appearance: none;
      background: #007AFF;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      font-size: 14px;
    }
    #search-input {
      width: 100%;
      padding: 8px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 5px;
      box-sizing: border-box;
    }
    .search-result {
      padding: 8px;
      border-bottom: 1px solid #eee;
    }
    .search-result:active {
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <div class="search-controls">
    <input type="text" id="search-input" placeholder="Search in PDF...">
    <div id="search-results"></div>
    <div id="search-navigation" style="display: none; margin-top: 8px;">
      <button id="prev-match">◀ Previous</button>
      <button id="next-match">Next ▶</button>
      <span id="match-count" style="margin-left: 10px; font-size: 14px;"></span>
    </div>
  </div>

  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // PDF.js setup
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let pdfDoc = null, pageNum = 1, pageRendering = false;
    const scale = window.innerWidth / 612 * 0.9; // Scale based on screen width
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    let textLayer = null;
    let searchMatches = [];
    let currentMatchIndex = -1;

    // Initialize service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }

    // File input handling (same as before)
    document.getElementById('file-input').addEventListener('change', handleFileSelect);

    // Search functionality optimized for mobile
    document.getElementById('search-input').addEventListener('input', debounce(handleSearch, 300));

    async function handleSearch() {
      const query = this.value.trim().toLowerCase();
      if (!pdfDoc || !query) {
        clearHighlights();
        document.getElementById('search-results').innerHTML = '';
        document.getElementById('search-navigation').style.display = 'none';
        return;
      }

      document.getElementById('search-results').innerHTML = 'Searching...';
      searchMatches = [];
      currentMatchIndex = -1;

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const page = await pdfDoc.getPage(i);
        const textContent = await page.getTextContent();
        
        textContent.items.forEach((item, itemIndex) => {
          const text = item.str.toLowerCase();
          let pos = text.indexOf(query);
          while (pos !== -1) {
            searchMatches.push({
              pageNum: i,
              itemIndex,
              startIndex: pos,
              endIndex: pos + query.length,
              text: item.str
            });
            pos = text.indexOf(query, pos + 1);
          }
        });
      }

      updateSearchResults();
    }

    function updateSearchResults() {
      const resultsContainer = document.getElementById('search-results');
      const searchNav = document.getElementById('search-navigation');
      
      if (searchMatches.length === 0) {
        resultsContainer.innerHTML = 'No matches found';
        searchNav.style.display = 'none';
        return;
      }

      let resultsHTML = '';
      const matchesByPage = {};
      
      searchMatches.forEach(match => {
        if (!matchesByPage[match.pageNum]) {
          matchesByPage[match.pageNum] = 0;
        }
        matchesByPage[match.pageNum]++;
      });

      resultsHTML = `<div style="margin-bottom: 5px;">Found ${searchMatches.length} matches:</div>`;
      
      Object.keys(matchesByPage).forEach(pageNum => {
        resultsHTML += `
          <div class="search-result" data-page="${pageNum}" style="padding: 5px 0;">
            Page ${pageNum}: ${matchesByPage[pageNum]} matches
          </div>`;
      });

      resultsContainer.innerHTML = resultsHTML;
      searchNav.style.display = 'flex';
      
      document.querySelectorAll('.search-result').forEach(el => {
        el.addEventListener('click', () => {
          const pageNum = parseInt(el.getAttribute('data-page'));
          const firstMatch = searchMatches.find(m => m.pageNum === pageNum);
          if (firstMatch) {
            currentMatchIndex = searchMatches.indexOf(firstMatch);
            goToMatch(currentMatchIndex);
          }
        });
      });

      if (searchMatches.length > 0) {
        currentMatchIndex = 0;
        goToMatch(currentMatchIndex);
      }
    }

    async function goToMatch(index) {
      if (index < 0 || index >= searchMatches.length) return;
      
      const match = searchMatches[index];
      currentMatchIndex = index;
      document.getElementById('match-count').textContent = `${index + 1}/${searchMatches.length}`;
      
      if (pageNum !== match.pageNum) {
        pageNum = match.pageNum;
        await renderPage(pageNum);
      }
      
      highlightMatch(match);
    }

    function highlightMatch(match) {
      clearHighlights();
      
      if (!textLayer) {
        textLayer = document.createElement('div');
        textLayer.className = 'textLayer';
        document.getElementById('pdf-container').appendChild(textLayer);
      }
      
      pdfDoc.getPage(match.pageNum).then(page => {
        const viewport = page.getViewport({ scale: scale });
        textLayer.innerHTML = '';
        
        const textDiv = document.createElement('div');
        textDiv.style.position = 'absolute';
        textDiv.style.lineHeight = '1';
        textDiv.textContent = match.text;
        textLayer.appendChild(textDiv);
        
        // Use PDF.js to position the text
        pdfjsLib.TextLayer.renderTextLayer({
          textContent: { items: [{ str: match.text, transform: [1,0,0,1,0,0] }] },
          container: textLayer,
          viewport: viewport,
          textDivs: [textDiv]
        });
        
        // Add highlight after positioning is done
        setTimeout(() => {
          const range = document.createRange();
          range.setStart(textDiv.firstChild, match.startIndex);
          range.setEnd(textDiv.firstChild, match.endIndex);
          
          const highlight = document.createElement('span');
          highlight.className = 'highlight active';
          range.surroundContents(highlight);
          
          // Scroll to highlight
          highlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 50);
      });
    }

    function clearHighlights() {
      if (textLayer) {
        textLayer.querySelectorAll('.highlight').forEach(el => {
          el.classList.remove('active');
        });
      }
    }

    // Helper function for better mobile performance
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this, args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    // Rest of your PDF viewer implementation...
    // (Keep all your existing file loading, page rendering, etc. code)
  </script>
</body>
</html>
