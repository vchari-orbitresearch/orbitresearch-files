<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF Navigator</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#ffffff" />
  <style>
    body { font-family: Arial; margin: 0; padding: 1rem; }
    #controls, #viewer { margin-top: 1rem; }
    canvas { width: 100%; border: 1px solid #ccc; }
    select, input[type="file"], button { margin: 0.5rem 0; display: block; }
    .highlight { background-color: yellow; }
    .search-nav { margin-top: 0.5rem; display: flex; gap: 0.5rem; }
    .search-result { cursor: pointer; color: blue; text-decoration: underline; }
    .search-result:hover { color: darkblue; }
  </style>
</head>
<body>
<input type="text" id="search-input" placeholder="Search in PDF..." style="width: 100%; margin-top: 1rem;" />
<div id="search-results" style="margin-top: 0.5rem;"></div>
<div id="search-navigation" class="search-nav" style="display: none;">
  <button id="prev-match">Previous Match</button>
  <button id="next-match">Next Match</button>
  <span id="match-count"></span>
</div>

<script>
  // PDF.js setup and other existing code remains the same until the search section

  // Search functionality variables
  let searchMatches = [];
  let currentMatchIndex = -1;
  let searchQuery = '';

  document.getElementById('search-input').addEventListener('input', async function() {
    searchQuery = this.value.trim().toLowerCase();
    if (!pdfDoc || !searchQuery) {
      clearHighlights();
      document.getElementById('search-results').innerHTML = '';
      document.getElementById('search-navigation').style.display = 'none';
      return;
    }

    document.getElementById('search-results').innerHTML = 'Searching...';
    searchMatches = [];
    currentMatchIndex = -1;

    const totalPages = pdfDoc.numPages;
    let processedPages = 0;

    for (let i = 1; i <= totalPages; i++) {
      const page = await pdfDoc.getPage(i);
      const textContent = await page.getTextContent();
      
      const textItems = textContent.items;
      let pageText = '';
      let pageMatches = [];

      // Process each text item to find matches
      textItems.forEach((item, itemIndex) => {
        const itemText = item.str.toLowerCase();
        if (itemText.includes(searchQuery)) {
          const startIndices = [];
          let index = item.str.toLowerCase().indexOf(searchQuery);
          while (index !== -1) {
            startIndices.push(index);
            index = item.str.toLowerCase().indexOf(searchQuery, index + 1);
          }
          
          startIndices.forEach(startIndex => {
            pageMatches.push({
              pageNum: i,
              itemIndex,
              startIndex,
              endIndex: startIndex + searchQuery.length,
              text: item.str
            });
          });
        }
        pageText += item.str + ' ';
      });

      if (pageMatches.length > 0) {
        searchMatches.push(...pageMatches);
      }

      processedPages++;
      if (processedPages === totalPages) {
        updateSearchResults();
      }
    }
  });

  function updateSearchResults() {
    const resultsContainer = document.getElementById('search-results');
    const searchNav = document.getElementById('search-navigation');
    
    if (searchMatches.length === 0) {
      resultsContainer.innerHTML = 'No matches found';
      searchNav.style.display = 'none';
      return;
    }

    // Group matches by page
    const matchesByPage = {};
    searchMatches.forEach(match => {
      if (!matchesByPage[match.pageNum]) {
        matchesByPage[match.pageNum] = [];
      }
      matchesByPage[match.pageNum].push(match);
    });

    // Display results
    let resultsHTML = `<div>Found ${searchMatches.length} match(es) on ${Object.keys(matchesByPage).length} page(s):</div>`;
    
    for (const pageNum in matchesByPage) {
      const pageMatches = matchesByPage[pageNum];
      resultsHTML += `<div class="search-result" data-page="${pageNum}">Page ${pageNum}: ${pageMatches.length} match(es)</div>`;
    }

    resultsContainer.innerHTML = resultsHTML;
    searchNav.style.display = 'flex';
    document.getElementById('match-count').textContent = `Match ${currentMatchIndex + 1} of ${searchMatches.length}`;

    // Add click handlers to page results
    document.querySelectorAll('.search-result').forEach(el => {
      el.addEventListener('click', () => {
        const pageNum = parseInt(el.getAttribute('data-page'));
        const firstMatchOnPage = searchMatches.find(m => m.pageNum === pageNum);
        if (firstMatchOnPage) {
          currentMatchIndex = searchMatches.indexOf(firstMatchOnPage);
          goToMatch(currentMatchIndex);
        }
      });
    });

    // Go to first match if any
    if (searchMatches.length > 0) {
      currentMatchIndex = 0;
      goToMatch(currentMatchIndex);
    }
  }

  function goToMatch(index) {
    if (index < 0 || index >= searchMatches.length) return;
    
    const match = searchMatches[index];
    currentMatchIndex = index;
    
    // Update UI
    document.getElementById('match-count').textContent = `Match ${index + 1} of ${searchMatches.length}`;
    
    // Go to page and highlight
    if (pageNum !== match.pageNum) {
      pageNum = match.pageNum;
      renderPage(pageNum).then((renderedPage) => {
        highlightMatch(match, renderedPage);
      });
    } else {
      pdfDoc.getPage(pageNum).then((currentPage) => {
        highlightMatch(match, currentPage);
      });
    }
  }

  async function highlightMatch(match, page) {
    clearHighlights();
    
    const textContent = await page.getTextContent();
    const textItem = textContent.items[match.itemIndex];

    // Recalculate viewport for highlighting, using the same scale as renderPage
    const scaleToRender = getOptimalScale(); // Ensure this matches renderPage's scale
    const viewport = page.getViewport({ scale: scaleToRender }); // Use the page object here

    // ... rest of your highlightMatch code remains similar
    // Ensure textLayerDiv's dimensions are also based on the displayed canvas size
    textLayerDiv.style.left = canvas.offsetLeft + 'px';
    textLayerDiv.style.top = canvas.offsetTop + 'px';
    textLayerDiv.style.width = canvas.style.width; // Use displayed width
    textLayerDiv.style.height = canvas.style.height; // Use displayed height
    document.body.appendChild(textLayerDiv);

    const textGeometry = pdfjsLib.TextLayer.renderTextLayer({
        textContent: {
            items: [textItem]
        },
        container: textLayerDiv,
        viewport: viewport, // Use the dynamically calculated viewport
        textDivs: []
    });
    
    // Wait for text layer to render
    setTimeout(() => {
      const textDiv = textLayerDiv.querySelector('.textLayer div');
      if (textDiv) {
        const range = document.createRange();
        const textNode = textDiv.childNodes[0];
        
        range.setStart(textNode, match.startIndex);
        range.setEnd(textNode, match.endIndex);
        
        const highlight = document.createElement('span');
        highlight.className = 'highlight';
        range.surroundContents(highlight);
        
        // Scroll to highlight
        highlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      
      // Clean up
      setTimeout(() => textLayerDiv.remove(), 1000);
    }, 100);
  }

  function clearHighlights() {
    document.querySelectorAll('.highlight').forEach(el => {
      el.outerHTML = el.innerHTML;
    });
  }

  // Navigation between matches
  document.getElementById('prev-match').addEventListener('click', () => {
    if (currentMatchIndex > 0) {
      currentMatchIndex--;
      goToMatch(currentMatchIndex);
    }
  });

  document.getElementById('next-match').addEventListener('click', () => {
    if (currentMatchIndex < searchMatches.length - 1) {
      currentMatchIndex++;
      goToMatch(currentMatchIndex);
    }
  });

  // Rest of your existing PDF viewer code remains the same...
</script>

  <h2>PDF Navigator</h2>
  <input type="file" id="file-input" accept="application/pdf" multiple />
  <select id="doc-select"></select>
  <div id="controls" style="display:none;">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    Page <span id="page-num">1</span> / <span id="page-count">--</span>
  </div>
  <div id="viewer">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    let pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null;
    const baseScale = 1.5; // Your desired base scale
    const devicePixelRatio = window.devicePixelRatio || 1;
    const scale = baseScale * devicePixelRatio;
    canvas = document.getElementById('pdf-canvas'), ctx = canvas.getContext('2d');
    const docSelect = document.getElementById('doc-select');
    let loadedFiles = [];

    document.getElementById('file-input').addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      loadedFiles.push(...files);
      renderDocSelect();
    });

    docSelect.addEventListener('change', () => {
      const index = parseInt(docSelect.value, 10);
      if (!isNaN(index)) loadPDF(index);
    });

    function renderDocSelect() {
      docSelect.innerHTML = '';
      loadedFiles.forEach((file, index) => {
        const option = document.createElement('option');
        option.textContent = file.name;
        option.value = index;
        docSelect.appendChild(option);
      });
      if (loadedFiles.length > 0) {
        docSelect.selectedIndex = loadedFiles.length - 1;
        loadPDF(loadedFiles.length - 1);
      }
    }

    function loadPDF(index) {
      const file = loadedFiles[index];
      const fileReader = new FileReader();
      fileReader.onload = function () {
        const typedArray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedArray).promise.then(function (pdf) {
          pdfDoc = pdf;
          document.getElementById('controls').style.display = 'block';
          document.getElementById('page-count').textContent = pdf.numPages;
          pageNum = 1;
          renderPage(pageNum);
        });
      };
      fileReader.readAsArrayBuffer(file);
    }

    function renderPage(num) {
      pageRendering = true;
      return pdfDoc.getPage(num).then(function (page) {
        const initialViewport = page.getViewport({ scale: 1.0})

        const viewrWidth = viewerDiv.clientWidth;
        let calculatedScale = viewerWidth / initialViewport.width;

        const devicePixelRatio = window.devicePixelRatio || 1;
        const finalRenderScale = calculatedScale * devicePixelRatio;

        const viewport = page.getViewport({ scale: finalRenderScale });

        canvas.height = viewport.height;
        canvas.width = viewport.width;

        canvas.style.width = viewerWidth + 'px';
        canvas.style.height = (viewport.height / viewport.width) + 'px';

        const renderContext = { canvasContext: ctx, viewport: viewport };
        const renderTask = page.render(renderContext);

        renderTask.promise.then(function () {
          pageRendering = false;
          if (pageNumPending !== null) {
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
        document.getElementById('page-num').textContent = num;
        return page;
      });
    }

    document.getElementById('prev').addEventListener('click', () => {
      if (pageNum <= 1) return;
      pageNum--;
      queueRenderPage(pageNum);
    });

    document.getElementById('next').addEventListener('click', () => {
      if (pageNum >= pdfDoc.numPages) return;
      pageNum++;
      queueRenderPage(pageNum);
    });

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }
  </script>
</body>
</html>
